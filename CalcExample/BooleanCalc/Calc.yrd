{
open Calc.AST
}

tokens {
	NOT of string
    | _ of string
}

options {
    translate = true
    module = "Calc.Parser"
    infEpsPath = epsilons
    pos = uint64
}

module Main

[<Start>]
program: (s=stmt SEMI{s})+ 

stmt:
	 v=VAR EQ e=boolExpr {v, e, BooleanT}
	 | v=VAR EQ e=arExpr {v, e, AriphmicT}
	 | e=arExpr {null, e, AriphmicT }


binExpr<operand binOp>: h=operand tl=(binOp operand)* {applyOp h tl}

boolExpr: binExpr<andExpr andOp>

andOp: AND {And}

andExpr: binExpr<notExpr orOp>

orOp: OR {Or}

notExpr:
	 LBRACE e=boolExpr RBRACE {e}
	| NOT e=boolExpr {UnaryOp(Not, e)}
	| v=VAR {EVar(v)}
	| e1=arExpr o=compOp e2=arExpr {CompOp(o, e1, e2)}
	| TRUE {BoolConst true} | FALSE {BoolConst false}
	| conditionExpr

compOp: LESS {Less} | GREATER {Greater} 
	  | LESSEQ {LessEq} | GREATEREQ {GreaterEq}
	  | EQ {Eq}

arExpr: binExpr<term termOp> 

termOp: PLUS {Plus} | MINUS {Minus}

term: binExpr<factor factorOp>
     
factorOp: MULT {Mult} | DIV {Div}

factor: binExpr<powExpr powOp>

powOp: POW {Pow}

powExpr:
   n=NUMBER {Num (float n)}
   | v=VAR {EVar(v)}
   | LBRACE e=arExpr RBRACE {e}
   | conditionExpr

expr: e=arExpr {e} | e=boolExpr {e}
conditionExpr: IF c=boolExpr THEN e1=expr ELSE e2=expr {ConditionStmt(c, e1, e2)}
